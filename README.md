# blockchain

Layer-1 Blockchain

## Mechanisms

### Code Structure

- Transaction - what is actually uploaded to blockchain

* Metadata (includes the key to content uploaded in external database) - generated when an instance of Transaction is created by hashing the trasaction metadata
* Transaction must support following structure: 1) Just upload 2) Message/Transfer - from/to (does not support group chat - always 1-to-1) 3) Parent/Child - comment, reply, like - will use source/target relation for now
* 1. Just upload - source: content hash, target: none
* 2. message/transfer - source: content hash, sender, target: recipient public key and amount
* 3. parent/child - source: content hash, child, target: transaction hash of parent
* Validate these properties in validation endpoint

* Contains transaction data
* Nodes receive Transaction

### Content storing

In actual implementation, we will use IPFS. Since IPFS supports CID (content identity) addressing, the node that receives transaction from an account will upload content to IPFS before broadcasting the transaction.

In this demo, we will

Since we are storing actual data in external database, content must be added to the external database as the block is appended to the chain. => uploading happens in the block class. the key of the content location is generated by the node.

When node broadcasts

### Node

Light Node

1. Receive transaction from user through REST and broadcast to other nodes
2. Receive block from other nodes and store in local
3. Provide REST endpoint to users to read data

Full Node

1. Do everything that light node does
2. Add block to blockchain => upload content to external database
3. Broadcast the new block to other nodes

Flagship Service Node

1. Manage private key for the user

### Problems

- Consensus Algorithm

* How does adding randomization work if all nodes need to know which one is the valiator?

- Punishment for troll node

- How to handle account (+stake of the account)

* Do we make account creation part of the blockchain or something different (i.e. account would interact with blockchain just through public key)

- How to prevent timestamp manipulation by a node?

### Plan

1. Put everything in RAM
2. Store everything in Json file
3. Use database to store the blockchain locally (content still in json file)
4. Upload content to S3

## Get started

1. Clone the repository
2. Set up virtual environment with Python version 3.8 (or above?). Please add the virtualenv directory to .gitignore if you use a different name.

```
$ python -m venv venv
```

3. Activate the virtual environment.

```
$ source venv/bin/activate
```

4. Download the packages. For `cryptography` follow instructions on https://cryptography.io/en/latest/installation/ if you need packages pre-installed.

```
(venv) $ pip install -r requirements.txt
```

5. Run the node locally. You must first set address of the node as an environment variable.

If you want to use example data to start with, run

```
(venv) $ python -m example_data.generate_example_data
```

In order to initialize a node with the example data, you need to set an environment `INIT_BLOCKCHAIN_FILE_NAME` with the json file name.

```
(venv) $ export ADDRESS=http://127.0.0.1:8000
(venv) $ export INIT_BLOCKCHAIN_FILE_NAME=blockchain_length2.json
(venv) $ uvicorn node.main:app --reload --port 8000
```

6. To run tests locally, run

```
(venv) $ python -m unittest discover test/
```

### Points of improvement

- Multiple transactions by same account in one block - make have problem in validation?
